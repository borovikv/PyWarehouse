'''
Created on 21.02.2012

@author: vb
'''
from PyQt4 import QtCore, QtGui
from PyQt4.QtWebKit import QWebPage, QWebView
import os
import re
import shutil
import urllib2
import locale
import urllib
import urlparse

from EditorPanel.EditorFilter import EditorFilter

locale.setlocale(locale.LC_ALL, '')
        



class Editor(QWebView):
    actionInsertImg = "IMG"
    actionCreateLink = "Link"
    actionInsertTable = "Table"
    actionInsertColAfter = "Insert col after"
    actionInsertRowAfter = "Insert row after"
    actionInsertColBefore = "Insert col before"
    actionInsertRowBefore = "Insert row before"
    actionStyleParagraph = "Paragraph"
    actionStyleHeading1 = "H1"
    actionStyleHeading2 = "H2"
    actionStyleHeading3 = "H3"
    actionStyleHeading4 = "H4"
    actionStyleHeading5 = "H5"
    actionStyleHeading6 = "H6"
    actionStylePreformatted = "Pre"
    actionStyleAddress = "Address"
    actionFormatStrikeThrough = "StrikeThrough"
    actionFormatAlighLeft = "Left"
    actionFormatAlighCenter = "Center"
    actionFormatAlighRight = "Right"
    actionFormatAlighJustify = "Justify"
    actionFormatIncreaseIndent = "Increase"
    actionFormatDecreaseIndent = "Decrease"
    actionFormatNumberedList = "Numbered list"
    actionFormatBulletedList = "Bulleted list"
    actionFormatFontName = "FontName"
    actionFormatFontSize = "Size"
    actionFormatTextColor = "TextColor"
    actionFormatBackgroundColor = "Highlight"
    actionEditUndo = "Undo"
    actionEditRedo = "Redo"
    actionEditCut = "Cut"
    actionEditCopy = "Copy"
    actionEditPaste = "Paste"
    actionFormatBold = "Bold"
    actionFormatItalic = "Italic"
    actionFormatUnderline = "Underline"

    def __init__(self, parent = None):
        QWebView.__init__(self, parent)
        
        print(os.pardir)
        self.sources = os.path.join(os.pardir, "Sources")  
        self.setCSS()
        self.setJS()
        self.createZoomPanel()
        self.createActions()  
        #clipboard = QtGui.QApplication.clipboard()
        #clipboard.dataChanged.connect(self.on_change_clipboard)
        self.installEventFilter(EditorFilter(self))
         
    def setJS(self):
        self.insertRowCol = open(os.path.join(self.sources, "insertRowCol.js")).read()

        
        
    def setCSS(self):
        css = os.path.join(self.sources, "MainCSS.css")
        cssUrl = QtCore.QUrl.fromLocalFile(css)
        self.settings().setUserStyleSheetUrl(cssUrl)
    #===========================================================================
    # Actions block
    #===========================================================================
    def createAction(self, name, func = None, shortcut = None, icon = None):
        action = QtGui.QAction(name, self)
        
        if icon:
            action.setIcon(self.getIcon(name))
            
        if func:   
            action.triggered.connect(func)
        
        if shortcut:
            shortcut = QtCore.Qt.CTRL + shortcut
            action.setShortcut(shortcut)
        
        self.addAction(action)
        
        return action
    
    def getIcon(self, actionName):
        path = os.path.join(os.pardir, "images", self.getIconName(actionName))
        icon = QtGui.QIcon(path)
        return icon
    
    def getIconName(self, actionName):
        return actionName + ".png"
    
        
    def createActions(self):
        
        self.createAction(Editor.actionInsertImg, self.insertImg, QtCore.Qt.Key_G,  True)
        self.createAction(Editor.actionInsertTable, self.insertTable, QtCore.Qt.Key_T,  True)
        self.createAction(Editor.actionInsertRowAfter, self.insertRowAfter, None,  True)
        self.createAction(Editor.actionInsertRowBefore, self.insertRowBefore, None,  True)
        self.createAction(Editor.actionInsertColAfter, self.insertColAfter, None,  True)
        self.createAction(Editor.actionInsertColBefore, self.insertColBefore, None, True)
        self.createAction(Editor.actionCreateLink, self.createLink, QtCore.Qt.Key_K,  True)
        
        self.createAction(Editor.actionFormatNumberedList, self.formatNumbereList, QtCore.Qt.Key_1,  True)
        self.createAction(Editor.actionFormatBulletedList, self.formatBulletedList, QtCore.Qt.Key_2,  True)
        
        self.createAction(Editor.actionStyleParagraph, self.styleParagraph, None,  True)
        self.createAction(Editor.actionStyleHeading1, lambda: self.styleHeading("h1"), None,  True)
        self.createAction(Editor.actionStyleHeading2, lambda: self.styleHeading("h2"), None,  True)
        self.createAction(Editor.actionStyleHeading3, lambda: self.styleHeading("h3"), None,  True)
        self.createAction(Editor.actionStyleHeading4, lambda: self.styleHeading("h4"), None,  True)
        self.createAction(Editor.actionStyleHeading5, lambda: self.styleHeading("h5"), None,  True)
        self.createAction(Editor.actionStyleHeading6, lambda: self.styleHeading("h6"), None,  True)
        
        self.createAction(Editor.actionStylePreformatted, self.stylePreformatted, None,  True)
        self.createAction(Editor.actionStyleAddress, self.styleAddress, None,  True)
        
        self.createAction(Editor.actionFormatAlighLeft,    self.formatAlighLeft, None,  True)
        self.createAction(Editor.actionFormatAlighRight,   self.formatAlighRight, None,  True)
        self.createAction(Editor.actionFormatAlighJustify, self.formatAlighJustify, None,  True)
        self.createAction(Editor.actionFormatAlighCenter,  self.formatAlighCenter, None,  True)
        self.createAction(Editor.actionFormatIncreaseIndent, self.formatIncreaseIndent, None,  True)
        self.createAction(Editor.actionFormatDecreaseIndent, self.formatDecreaseIndent, None,  True)
        
        self.createAction(Editor.actionFormatFontName, self.formatFontName, None,  True)
        self.createAction(Editor.actionFormatFontSize, self.formatFontSize, None,  True)
        self.createAction(Editor.actionFormatTextColor, self.formatTextColor, None,  True)
        self.createAction(Editor.actionFormatBackgroundColor, self.formatBackgroundColor, QtCore.Qt.Key_Q,  True)
        
        self.createAction(Editor.actionEditCut, None, None,  True)
        self.createAction(Editor.actionEditCopy, None, None,  True)
        self.createAction(Editor.actionEditPaste, None, None,  True)
        self.createAction(Editor.actionEditRedo, None, QtCore.Qt.Key_Z,  True)
        self.createAction(Editor.actionEditUndo, None, QtCore.Qt.Key_Y,  True)
        
        self.createAction(Editor.actionFormatBold, None, QtCore.Qt.Key_B,  True)
        self.createAction(Editor.actionFormatItalic, None, QtCore.Qt.Key_I,  True)
        self.createAction(Editor.actionFormatUnderline, None, QtCore.Qt.Key_U,  True)
        self.createAction(Editor.actionFormatStrikeThrough, self.formatStrikeThrough, QtCore.Qt.Key_3,  True)
            
        self.call_forward_action()

    def getAction(self, actionName):
        
        for i in self.actions():
            if i.text() == actionName: 
                return i
        return None

    def call_forward_action(self):
        self.forward_action(self.getAction(Editor.actionEditUndo), self.page().Undo)
        self.forward_action(self.getAction(Editor.actionEditRedo) , self.page().Redo)
        self.forward_action(self.getAction(Editor.actionEditCut), self.page().Cut)
        self.forward_action(self.getAction(Editor.actionEditCopy), self.page().Copy)
        self.forward_action(self.getAction(Editor.actionEditPaste), self.page().Paste)
        self.forward_action(self.getAction(Editor.actionFormatBold), self.page().ToggleBold)
        self.forward_action(self.getAction(Editor.actionFormatItalic), self.page().ToggleItalic)
        self.forward_action(self.getAction(Editor.actionFormatUnderline), self.page().ToggleUnderline)
        
    def forward_action(self, act1, act2):
        self.connect(act1, QtCore.SIGNAL("triggered()"), self.pageAction(act2), QtCore.SLOT("trigger()"))
        self.connect(self.pageAction(act2), QtCore.SIGNAL("changed()"), self.adjustActions)
        
    def follow_enable(self, a1, a2):
        a1.setEnabled(self.pageAction(a2).isEnabled())
        
    def follow_check(self, a1, a2):
        a1.setChecked(self.pageAction(a2).isChecked())
        
    def adjustActions(self):
        self.follow_enable(self.getAction(Editor.actionEditUndo), self.page().Undo)
        self.follow_enable(self.getAction(Editor.actionEditRedo), self.page().Redo)
        self.follow_enable(self.getAction(Editor.actionEditCut), self.page().Cut)
        self.follow_enable(self.getAction(Editor.actionEditCopy), self.page().Copy)
        self.follow_enable(self.getAction(Editor.actionEditPaste), self.page().Paste)
        self.follow_check(self.getAction(Editor.actionFormatBold), self.page().ToggleBold)
        self.follow_check(self.getAction(Editor.actionFormatItalic), self.page().ToggleItalic)
        self.follow_check(self.getAction(Editor.actionFormatUnderline), self.page().ToggleUnderline)
    
        self.getAction(Editor.actionFormatStrikeThrough).setChecked(self.queryCommandState("strikeThrough"))
        self.getAction(Editor.actionFormatNumberedList).setChecked(self.queryCommandState("insertOrderedList"))
        self.getAction(Editor.actionFormatBulletedList).setChecked(self.queryCommandState("insertUnorderedList"))
        
    def connectAction(self, actionName):
        action = self.actionsEdit[actionName]
        if self.actionFunc.has_key(actionName):
            action.triggered.connect(self.actionFunc[actionName])
        
        
    def createZoomPanel(self):
        self.zoomSlider = QtGui.QSlider(self)  
        self.zoomSlider.setOrientation(QtCore.Qt.Horizontal)
        self.zoomSlider.setMaximumWidth(150)
        self.zoomSlider.setRange(25, 400)
        self.zoomSlider.setSingleStep(25)
        self.zoomSlider.setPageStep(100)
        self.zoomSlider.setValue(self.zoomFactor() * 100)
        self.zoomSlider.valueChanged[int].connect(self.changeZoom)
        
    #===========================================================================
    # File operation
    #===========================================================================
    def loadFromPath(self, path):
        if not QtCore.QFile.exists(path):
            return False
        
        f = QtCore.QFile(path)
        if not f.open(QtCore.QFile.ReadOnly):
            return False
        data = f.readAll()
        
        self.setContent(data, "text/html", baseUrl = QtCore.QUrl.fromLocalFile(path))
        self.page().setContentEditable(True)
        self.page().setLinkDelegationPolicy(QWebPage.DelegateAllLinks)
        self.linkClicked[QtCore.QUrl].connect(self.openLink)
        self.setPath(path)
#        self.setUrl(QtCore.QUrl.fromLocalFile(path))
        return True
        
    def openLink(self, url):
        QtGui.QDesktopServices.openUrl(url)
    
    def openDoc(self, path):
        self.loadFromPath(path)
        
    
    def saveDoc(self, path = None):
        if not path:
            path = self.path
        
        data =  QtCore.QFile(path)
        success = data.open(QtCore.QFile.WriteOnly | QtCore.QFile.Truncate)
        if success:        
            html = self.page().mainFrame().toHtml()
            html = html.toUtf8()
            c = data.write(html)
            success = (c >= html.length())
  
        self.setWindowModified(False)
        return success
        
    def setPath(self, path):
        self.path  = path
    
    def getSourceHtml(self):
        return os.path.join(self.sources, "sources.html")

    
    def newDoc(self):
        source = QtCore.QFile(self.getSourceHtml())
        source.open(QtCore.QIODevice.ReadOnly)
        html = QtCore.QString.fromUtf8(source.readAll())
        self.page().mainFrame().setHtml(html)
        
        self.setFocus()
        self.page().setContentEditable(True)
        self.setPath("")
        
        mx = self.width() / 2
        my = self.height() / 2
        center = QtCore.QPoint(mx, my)
        e1 = QtGui.QMouseEvent(QtCore.QEvent.MouseButtonPress, center, 
                               QtCore.Qt.LeftButton, 
                               QtCore.Qt.LeftButton, 
                               QtCore.Qt.NoModifier)
        e2 = QtGui.QMouseEvent(QtCore.QEvent.MouseButtonRelease, center, 
                               QtCore.Qt.LeftButton, 
                               QtCore.Qt.LeftButton, 
                               QtCore.Qt.NoModifier)
        QtGui.QApplication.postEvent(self, e1)
        QtGui.QApplication.postEvent(self, e2)
    
    #===========================================================================
    # What can do 
    #===========================================================================
  
    def insertImg(self):
        filters  = self.tr("Image Files (*.png *.jpg *.bmp);;")
        filters += self.tr("Portable Network Graphics (PNG) (*.png);;")
        filters += self.tr("JPEG (*.jpg *.jpeg);;")
        filters += self.tr("GIF (*.gif);;")
        filters += self.tr("All Files (*)")
        img = QtGui.QFileDialog.getOpenFileNameAndFilter(self, QtCore.QString(), filter=filters)
        
        if img[0].isEmpty() or not QtCore.QFile.exists(img[0]):
            return
        
        urlImg = QtCore.QUrl.fromLocalFile(img[0])
        self.execCommand("InsertImage", urlImg.toString())
    
    def createLink(self):
        link = QtGui.QInputDialog.getText(self, self.tr("Create link"), "Enter URL")[0]
        
        if not link.isEmpty():
            url = self.guessUrlFromString(link)
            if url.isValid():
                self.execCommand("createLink", url.toString())
    
    def guessUrlFromString(self, link):
        urlStr = link.trimmed()
        test = QtCore.QRegExp("^[a-zA-Z]+\\:.*")
        
        # check if it looks like a qualified URL. try parsing it end see
        hasSchema = test.exactMatch(urlStr)
        if hasSchema:
            url = QtCore.QUrl(urlStr, QtCore.QUrl.TolerantMode)
            if url.isValid():
                return url
        
        # Might be a file
        if QtCore.QFile.exists(urlStr):
            return QtCore.QUrl.fromLocalFile(urlStr)
        
        # Might be a shorturl - try to detect the schema
        if not hasSchema:
            dotIndex = urlStr.indexOf('.')
            if dotIndex != 1:
                prefix = urlStr.left(dotIndex).toLower()
                schema = prefix if prefix is "ftp" else "http"
                url = QtCore.QUrl(schema + "://" + urlStr, QtCore.QUrl.TolerantMode)
                if url.isValid():
                    return url
            
            return QtCore.QUrl(link, QtCore.QUrl.TolerantMode)    
        
    def insertTable(self):
        selectedText = str(self.selectedText())
        if selectedText:
            rc = selectedText.split(",")
            row = int(rc[0])
            col = int(rc[1])
        else:
            row = 1
            col = 1
        htmlText = "<table cellspacing='0' cellpadding='5' border='1'>"
        for i in range(row):
            htmlText += "<tr>"
            for j in range(col):
                htmlText += "<td> </td>"
            htmlText += "</tr>"
        htmlText += "</table>"
        
        self.insertHtml(htmlText)
    
    def insertHtml(self, htmlText):
        self.execCommand("insertHTML", htmlText) 
        
    def insertColAfter(self):
        self.evaluateJavaScript(self.insertRowCol + " insertColAfter()" )
    def insertColBefore(self):
        self.evaluateJavaScript(self.insertRowCol + " insertColBefore()" )
    
    def insertRowAfter(self):
        self.evaluateJavaScript(self.insertRowCol + " insertRowAfter()" )
    def insertRowBefore(self):
        self.evaluateJavaScript(self.insertRowCol + " insertRowBefore()" )
    
    def styleParagraph(self):
        self.execCommand("formatBlock", "p")
    
    def styleHeading(self, headingType):
        self.execCommand("formatBlock", headingType)
    
    def stylePreformatted(self):
        self.execCommand("formatBlock", "pre")
    
    def styleAddress(self):
        self.execCommand("formatBlock", "address")
    
    def formatStrikeThrough(self):
        self.execCommand("strikeThrough")
    
    def formatAlighLeft(self):
        self.execCommand("justifyLeft")
    
    def formatAlighCenter(self):
        self.execCommand("justifyCenter")
    
    def formatAlighRight(self):
        self.execCommand("justifyRight")
    
    def formatAlighJustify(self):
        self.execCommand("justifyFull")
        
    def formatIncreaseIndent(self):
        self.execCommand("indent")
    
    def formatDecreaseIndent(self):
        self.execCommand("outdent")
        
    def formatNumbereList(self):
        self.execCommand("insertOrderedList")

    def formatBulletedList(self):
        self.execCommand("insertUnorderedList")    
    
    def formatFontName(self):
        families = QtGui.QFontDatabase.families()
        
        family = QtGui.QInputDialog.getItem(self, self.tr("Font"), self.tr("Select font:"), families, 0, False)
        if family[1]:
            self.execCommand("fontName", family[0])
    
    def formatFontSize(self):
        sizes = QtCore.QStringList()
        sizes << "xx-small"
        sizes << "x-small"
        sizes << "small"
        sizes << "medium"
        sizes << "large"
        sizes << "x-large"
        sizes << "xx-large"
        
        size = QtGui.QInputDialog.getItem(self, self.tr("Font Size"), self.tr("Select font size:"), sizes, sizes.indexOf("medium"), False)
        if size[1]:
            self.execCommand("fontSize", QtCore.QString.number(sizes.indexOf(size[0])))
    
    
    def formatColor(self, what, qtInitialColor):
        color = QtGui.QColorDialog.getColor(qtInitialColor, self)    
        if color.isValid():
            self.execCommand(what + "Color", color.name())
    
    def formatTextColor(self):
        self.formatColor("fore", QtCore.Qt.black)
         
    def formatBackgroundColor(self):
        self.formatColor("hilite", QtCore.Qt.yellow) 
        
    def pastePreparation(self):
        clipboard = QtGui.QApplication.clipboard()
        
        text = clipboard.text("html")
        if text:
            imgs = self.getAllImg(text)
            if imgs:
                newImgs = self.copyImg(imgs)
                if newImgs:
                    for img in newImgs:
                        if img and newImgs[img]:
                            old = QtCore.QString(img)
                            new = QtCore.QString(newImgs[img])
                            text.replace(old, new)
            data = QtCore.QMimeData()
    
            data.setHtml(text)
            clipboard.setMimeData(data)
                
    def getAllImg(self, html):
        imgReg = re.compile("<img\s[^>]*?>")
        match = imgReg.findall(html)
        return match
    
    def copyImg(self, imgs):
        newImgs = {}
        for img in imgs:
            newImgs[img] = self.copyFileImg(img)
        return newImgs
    
#    def foo(self):
#        cache = QtNetwork.QNetworkDiskCache()
#        cache.setCacheDirectory(QtCore.QDir.currentPath() + QtCore.QDir.separator() + "cashe")
#        ntw = self.page().networkAccessManager()
#        ntw.setCache(cache)
#        ntw.cache().data(QtCore.QUrl())
#        root = self.page().mainFrame().documentElement()
#        root.findAll("#image")[0].attribute("src")
        
        
    def copyFileImg(self, img):
        imgReg = re.compile("src\s*=\s*[\"'][^\"]*?[\"']")
        oldPath = imgReg.search(img).group()
        oldPath = oldPath.split('"')[1]
        path = self.copyFile(oldPath)
        if path:
            img = "" + img        
            img.replace(oldPath, path)
            return img
        else:
            return None      
               
    def copyFile(self, src):

        dest = os.path.dirname(self.path)
        dest += os.sep + "IMG"
        if not os.path.exists(dest):
            os.mkdir(dest) 
        
        link = self.getFullPathFromStr(self.linkPreparation(src))
  
        if link:
            path = link["link"]
            if link["type"] == "http":
                newPath = "IMG" + os.sep + self.downloadFile(path, dest)
                
            if link["type"] == "local":
                try:
                    fileName = os.path.basename(path)                    
                    newFile = os.path.join(dest, fileName)
                    
                    if os.path.exists(newFile) and self.path != self.urlForCopy:
                        f, ext = os.path.splitext(fileName)
                        s = re.search("(.*)\(([0-9]+)\)$", f)
                        if s:
                            counter = int(s.group(2))
                            counter = "(" + str(counter + 1) + ")"
                            fn = s.group(1) + counter + ext
                        else:
                            fn = f + "(1)" + ext
                        
                        dst = os.path.join(dest, fn)
                        shutil.copyfile(path, dst)
                    elif not os.path.exists(newFile):
                        shutil.copy(path, dest)
                    newPath = "IMG" + os.sep + fileName
                except:
                    print("exept")
                    newPath = None
        else:
            newPath = None
                     
        return newPath
    
    def setUrlForCopy(self):
        self.urlForCopy = self.path
    
    def linkPreparation(self, link):
        s = unicode(link, "utf-8")  
        s = s.replace("&amp;", "&")  
        try:
            return self.decodeURI(s)
        except:
            print("bad decode")
            return s
        
        
    def downloadFile(self, url, destination):
        filepath, filename = os.path.split(urlparse.urlparse(url).path)
        urllib.urlretrieve(url, destination + os.sep + filename)
        return filename
    
    def decodeURI(self, uri):
        return urllib.unquote(uri.encode('ascii'))    
    
    def getFullPathFromStr(self, link):
        
        objUrl = urlparse.urlparse(link)
        
        if objUrl.scheme == 'file' and os.path.exists(objUrl.path):
            return {"type": "local", "link" : objUrl.path}
        
        if objUrl.scheme == 'http':
            return {"type": "http", "link" : link}
        
        if objUrl.netloc:
            try:
                fullpath = 'http' + link
                urllib2.urlopen(fullpath)
                return {"type": "http", "link" : fullpath}
            except:
                print("bad location")
                
        if objUrl.path.startswith('www.'):
            #try to open file on http if false fale may by local
            try:
                fullpath = "http://" + link
                urllib2.urlopen(fullpath)
                return {"type": "http", "link" : fullpath}
            except:
                print("bad location")        
        
        # Might be a file
        if os.path.exists(link):
            return {"type": "local", "link" : link}
        
        # Might be a shorturl 
        if self.urlForCopy:
            print(link, objUrl, self.urlForCopy)
            par = os.path.dirname(self.urlForCopy)
            fullpath = os.path.join(par, link)
            return {"type" : "local", "link" : fullpath}
        
        # Might be a shorturl from www or other surces
            
        return None    
    #===========================================================================
    # Window manipulation
    #===========================================================================
    def createMenu(self):
        menu = QtGui.QMenu(self)
        
        menu.addAction(self.getAction(Editor.actionEditUndo))
        menu.addAction(self.getAction(Editor.actionEditRedo))
        menu.addSeparator()
        menu.addAction(self.getAction(Editor.actionInsertImg))
        menu.addAction(self.getAction(Editor.actionCreateLink))
        menu.addSeparator()
        menu.addAction(self.getAction(Editor.actionInsertTable))
        menu.addAction(self.getAction(Editor.actionInsertRowBefore))
        menu.addAction(self.getAction(Editor.actionInsertRowAfter))
        menu.addAction(self.getAction(Editor.actionInsertColBefore))
        menu.addAction(self.getAction(Editor.actionInsertColAfter))
        menu.addSeparator()
        menu.addAction(self.getAction(Editor.actionFormatBulletedList))
        menu.addAction(self.getAction(Editor.actionFormatNumberedList))
        menu.addSeparator()
        menu.addAction(self.getAction(Editor.actionFormatStrikeThrough))
        menu.addAction(self.getAction(Editor.actionFormatBackgroundColor))
        menu.addSeparator()
        return menu
    
    def contextMenuEvent(self, event):
        if not hasattr(self, "menu"):
            self.menu = self.createMenu()
        
        self.menu.exec_(event.globalPos())
        
    def changeZoom(self, percent):
        factor = float(percent) / 100
        self.setZoomFactor(factor)
        self.zoomSlider.setValue(percent)
        
    #===========================================================================
    # Utils
    #===========================================================================
    def tr(self, str_):
        return QtCore.QObject.tr(QtCore.QObject(), str_)
    
    def execCommand(self, cmd, arg = None):
        if arg:
            jsString = QtCore.QString("document.execCommand(\"%1\", false, \"%2\")").arg(cmd).arg(arg)
        else:
            jsString = QtCore.QString("document.execCommand(\"%1\", false, null)").arg(cmd)
        self.evaluateJavaScript(jsString)
    
    def queryCommandState(self, cmd):
        js = QtCore.QString("document.queryCommandState(\"%1\", false, null)").arg(cmd);
        result = self.evaluateJavaScript(js)
        return result.toString().simplified().toLower() == "true"; 
    
    def evaluateJavaScript(self, js):
        frame = self.page().mainFrame()
        return frame.evaluateJavaScript(js);
